# Centralized IO Handling Concept

This document outlines the IO handling architecture implemented in the TerminalGame project. This centralized approach can be implemented in other repositories to achieve a clean separation of concerns, multi-threading support, and consistent user interface experiences.

## Implementation Status

This document now includes implementation status markers:
- ‚úÖ Fully implemented
- ‚ö†Ô∏è Partially implemented
- üîÑ Ready for integration (implemented but not integrated into existing code)
- ‚ùå Not yet implemented

## Core Principles

1. **Separation of Concerns**: Input and output handling are completely decoupled from game logic. ‚úÖ
2. **Thread Safety**: Input handling runs in a separate thread to ensure UI responsiveness. ‚úÖ
3. **Abstraction Layers**: Hardware-specific code is abstracted away from application logic. ‚úÖ
4. **Centralized Management**: All IO operations go through dedicated handlers. ‚úÖ
5. **Extensibility**: Design supports adding new input/output types without modifying core logic. ‚úÖ

## Input Handling Architecture

### Components

1. **Input Handler (src/io/input/input_handler.h/c)** ‚úÖ
   - Initializes and manages a dedicated input thread
   - Maintains a circular buffer for input events
   - Translates hardware-specific events into application-specific input types
   - Provides thread-safe methods to retrieve pending inputs

### Implementation Details

1. **Input Enumeration**: ‚úÖ
   - Define an application-specific input enumeration (input_t) that maps various inputs (keyboard, mouse, etc.) to logical actions.
   - Example: UP, DOWN, LEFT, RIGHT, ENTER, ESCAPE, etc.

2. **Threaded Event Processing**: ‚úÖ
   - Input events are processed in a dedicated thread to prevent UI blocking.
   - Thread continuously polls for hardware events and converts them to the application's input type.
   - Uses a circular buffer to store inputs between processing cycles.

3. **Interface**: ‚úÖ
   - `init_input_handler()`: Initializes the handler and starts the input thread.
   - `get_input_blocking()`: Retrieves the next input from the buffer (blocking).
   - `get_input_nonblocking()`: Retrieves the next input from the buffer (non-blocking).
   - `shutdown_input_handler()`: Cleans up resources and stops the input thread.

## Output Handling Architecture

### Components

1. **Common Output (src/io/output/common/common_output.h/c)** ‚úÖ
   - Provides basic text and menu rendering functionality
   - Abstracts terminal/display operations

2. **Specialized Output (src/io/output/specific/...)** ‚úÖ
   - Domain-specific rendering:
     - map_output.c for map rendering ‚úÖ
     - stats_output.c for character stats ‚úÖ
     - inventory_output.c for items and equipment ‚úÖ
     - combat_output.c for combat scenarios ‚úÖ

3. **Color Management (src/io/colors.h)** ‚úÖ
   - Defines a platform-independent color enumeration
   - Maps internal colors to hardware-specific color codes

### Implementation Details

1. **Abstracted Rendering Functions**: ‚úÖ
   - `print_text()`: Renders text with specified colors at given coordinates
   - `print_menu()`: Renders interactive menus with selection highlighting
   - `clear_screen()`: Clears the display
   - `draw_box()`: Draws bordered boxes for UI elements
   - `render_frame()`: Renders all changes to the screen

2. **Specialized Renderers**: ‚úÖ
   - Map renderer displays the game world with fog of war
   - Stats renderer shows character attributes and leveling
   - Inventory renderer displays items and equipment
   - Combat renderer visualizes combat situations with animations

3. **Media Output**: ‚úÖ
   - Supports displaying images and animated GIFs
   - Handled by `media_output.h/c`

4. **Interface Consistency**: ‚úÖ
   - All output functions follow similar parameter patterns (x, y coordinates, content, colors)
   - Functions handle boundary validation and error logging

## Menu System Integration

The menu system (src/io/menu/menu.h/c) demonstrates how input and output systems integrate: ‚úÖ

1. **Menu Structure**: ‚úÖ
   - Defines a menu_t structure containing title, options, selection state
   - Handles navigation state internally

2. **Input-Output Loop**: ‚úÖ
   - `menu_handle_input()` processes input events to update menu state
   - `menu_render()` renders the menu based on its current state
   - `menu_run()` combines input handling and rendering in a loop
   - Returns semantic results based on user interaction (selection, cancel, exit)

3. **Menu Specializations**: ‚úÖ
   - Main menu (main_menu.h/c) for game startup options
   - Pause menu (pause_menu.h/c) for in-game pausing
   - Dialog system (dialog.h/c) for messages and confirmations

## Localization Architecture

**Note**: Localization is being handled in a separate branch. The IO system is designed to work with the existing localization methods without modification. ‚ö†Ô∏è

## Current Implementation and Dependencies

The centralized IO system has been implemented with the following components and dependencies:

### Dependencies

1. **External Libraries**:
   - Notcurses: Used for all terminal/display operations
   - pthread (Linux/macOS) / WinAPI threads (Windows): For threading support

2. **Internal Dependencies**:
   - logging/logger.h/c: For error and debug logging
   - logging/ringbuffer.h/c: For thread-safe communication between threads
   - thread/thread_handler.h/c: For platform-independent thread creation
   - local/local.h/c: For localization (usage only, not modified)
   - character/character.h: For character stats and resources
   - map/map.h: For map data structures
   - combat/ability.h and combat/damage.h: For combat mechanics

### Implementation Notes

1. **Thread Safety**:
   - Input handling runs in its own thread
   - Output handler has mutex protection for thread-safe rendering
   - Uses existing ringbuffer for thread communication

2. **Cross-Platform Support**:
   - Windows, Linux, and macOS support
   - Platform-specific code for threads and timing is isolated
   - Platform-specific input event types are handled appropriately

3. **Notcurses Integration**:
   - All rendering is done through Notcurses
   - Input is captured via Notcurses' input functions
   - Media display leverages Notcurses' visual capabilities

4. **Performance Considerations**:
   - Non-blocking input checks to prevent UI freezing
   - Optimized rendering with batched updates
   - Sleep timing in threads to reduce CPU usage

## Integration Path (Future Work) üîÑ

The IO system is fully implemented but not yet integrated into the existing game code. The integration will follow these steps:

1. Update the main game loop to use the centralized IO handler
2. Replace direct Notcurses calls with calls to our abstraction layer
3. Gradually migrate each game mode to use the specialized renderers
4. Start with map_mode.c as it has the simplest interactions
5. Ensure all functionality works correctly before proceeding to the next mode

IMPORTANT NOTE: we need to use the notcurses library and all it's available functionality for all input and output handling!