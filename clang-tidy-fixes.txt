../src/character_stats.c:6:5: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    6 |     strncpy(c->name, name, sizeof(c->name) - 1);
      |     ^~~~~~~
../src/character_stats.c:6:5: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
    6 |     strncpy(c->name, name, sizeof(c->name) - 1);
      |     ^~~~~~~
../src/character_stats.c:19:5: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   19 |     strncpy(a->name, name, sizeof(a->name) - 1);
      |     ^~~~~~~
../src/character_stats.c:19:5: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
   19 |     strncpy(a->name, name, sizeof(a->name) - 1);
      |     ^~~~~~~
../src/character_stats.c:46:23: warning: comparison of integers of different signs: 'int' and 'unsigned long' [clang-diagnostic-sign-compare]
   46 |     for (int i = 0; i < sizeof(m->weakness_map); i++) {
      |                     ~ ^ ~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:141:17: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  141 |                 snprintf(message, sizeof(message), "Used %s! Dealt %d damage. Press any key to continue...", player->base.abilities[selected_index].name, damage_dealt);
      |                 ^~~~~~~~
../src/combat_mode.c:141:17: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  141 |                 snprintf(message, sizeof(message), "Used %s! Dealt %d damage. Press any key to continue...", player->base.abilities[selected_index].name, damage_dealt);
      |                 ^~~~~~~~
../src/combat_mode.c:147:17: warning: Value stored to 'y' is never read [clang-analyzer-deadcode.DeadStores]
  147 |                 y = print_combat_view(&player->base, &monster->base, false);
      |                 ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:147:17: note: Value stored to 'y' is never read
  147 |                 y = print_combat_view(&player->base, &monster->base, false);
      |                 ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:203:75: warning: Division by zero [clang-analyzer-core.DivideZero]
  203 |                 selected_index = (selected_index - 1 + usable_item_count) % usable_item_count;
      |                                                                           ^
../src/combat_mode.c:15:12: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:12: note: Left side of '&&' is true
../src/combat_mode.c:15:39: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:5: note: Loop condition is true.  Entering loop body
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |     ^
../src/combat_mode.c:16:9: note: Control jumps to 'case MENU_COMBAT:'  at line 17
   16 |         switch (current_state) {
      |         ^
../src/combat_mode.c:19:17: note:  Execution continues on line 15
   19 |                 break;
      |                 ^
../src/combat_mode.c:15:12: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:12: note: Left side of '&&' is true
../src/combat_mode.c:15:39: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:5: note: Loop condition is true.  Entering loop body
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |     ^
../src/combat_mode.c:16:9: note: Control jumps to 'case MENU_ITEM:'  at line 27
   16 |         switch (current_state) {
      |         ^
../src/combat_mode.c:28:21: note: Calling 'item_menu'
   28 |                 if (item_menu(player, monster)) {// Only attack if item was used
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:165:5: note: 'usable_item_count' initialized to 0
  165 |     int usable_item_count = 0;
      |     ^~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:170:21: note: Assuming 'i' is >= field 'item_count'
  170 |     for (int i = 0; i < player->item_count; i++) {
      |                     ^~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:170:5: note: Loop condition is false. Execution continues on line 176
  170 |     for (int i = 0; i < player->item_count; i++) {
      |     ^
../src/combat_mode.c:176:5: note: Loop condition is true.  Entering loop body
  176 |     while (true) {
      |     ^
../src/combat_mode.c:183:9: note: Loop condition is false. Execution continues on line 191
  183 |         for (int i = 0; i < usable_item_count; i++) {
      |         ^
../src/combat_mode.c:200:13: note: Assuming field 'type' is equal to TB_EVENT_KEY
  200 |         if (event.type == TB_EVENT_KEY) {
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:200:9: note: Taking true branch
  200 |         if (event.type == TB_EVENT_KEY) {
      |         ^
../src/combat_mode.c:201:17: note: Assuming the condition is true
  201 |             if (event.key == TB_KEY_ARROW_UP) {
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:201:13: note: Taking true branch
  201 |             if (event.key == TB_KEY_ARROW_UP) {
      |             ^
../src/combat_mode.c:203:75: note: Division by zero
  203 |                 selected_index = (selected_index - 1 + usable_item_count) % usable_item_count;
      |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:206:55: warning: Division by zero [clang-analyzer-core.DivideZero]
  206 |                 selected_index = (selected_index + 1) % usable_item_count;
      |                                                       ^
../src/combat_mode.c:15:12: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:12: note: Left side of '&&' is true
../src/combat_mode.c:15:39: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:5: note: Loop condition is true.  Entering loop body
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |     ^
../src/combat_mode.c:16:9: note: Control jumps to 'case MENU_COMBAT:'  at line 17
   16 |         switch (current_state) {
      |         ^
../src/combat_mode.c:19:17: note:  Execution continues on line 15
   19 |                 break;
      |                 ^
../src/combat_mode.c:15:12: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:12: note: Left side of '&&' is true
../src/combat_mode.c:15:39: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:5: note: Loop condition is true.  Entering loop body
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |     ^
../src/combat_mode.c:16:9: note: Control jumps to 'case MENU_ITEM:'  at line 27
   16 |         switch (current_state) {
      |         ^
../src/combat_mode.c:28:21: note: Calling 'item_menu'
   28 |                 if (item_menu(player, monster)) {// Only attack if item was used
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:165:5: note: 'usable_item_count' initialized to 0
  165 |     int usable_item_count = 0;
      |     ^~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:170:21: note: Assuming 'i' is >= field 'item_count'
  170 |     for (int i = 0; i < player->item_count; i++) {
      |                     ^~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:170:5: note: Loop condition is false. Execution continues on line 176
  170 |     for (int i = 0; i < player->item_count; i++) {
      |     ^
../src/combat_mode.c:176:5: note: Loop condition is true.  Entering loop body
  176 |     while (true) {
      |     ^
../src/combat_mode.c:183:9: note: Loop condition is false. Execution continues on line 191
  183 |         for (int i = 0; i < usable_item_count; i++) {
      |         ^
../src/combat_mode.c:200:13: note: Assuming field 'type' is equal to TB_EVENT_KEY
  200 |         if (event.type == TB_EVENT_KEY) {
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:200:9: note: Taking true branch
  200 |         if (event.type == TB_EVENT_KEY) {
      |         ^
../src/combat_mode.c:201:17: note: Assuming the condition is false
  201 |             if (event.key == TB_KEY_ARROW_UP) {
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:201:13: note: Taking false branch
  201 |             if (event.key == TB_KEY_ARROW_UP) {
      |             ^
../src/combat_mode.c:204:24: note: Assuming the condition is true
  204 |             } else if (event.key == TB_KEY_ARROW_DOWN) {
      |                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:204:20: note: Taking true branch
  204 |             } else if (event.key == TB_KEY_ARROW_DOWN) {
      |                    ^
../src/combat_mode.c:206:55: note: Division by zero
  206 |                 selected_index = (selected_index + 1) % usable_item_count;
      |                                  ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:209:17: warning: 3rd function call argument is an uninitialized value [clang-analyzer-core.CallAndMessage]
  209 |                 use_item(player, monster, usable_items[selected_index]);
      |                 ^
../src/combat_mode.c:15:12: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:12: note: Left side of '&&' is true
../src/combat_mode.c:15:39: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:5: note: Loop condition is true.  Entering loop body
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |     ^
../src/combat_mode.c:16:9: note: Control jumps to 'case MENU_COMBAT:'  at line 17
   16 |         switch (current_state) {
      |         ^
../src/combat_mode.c:19:17: note:  Execution continues on line 15
   19 |                 break;
      |                 ^
../src/combat_mode.c:15:12: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:12: note: Left side of '&&' is true
../src/combat_mode.c:15:39: note: Assuming field 'health' is > 0
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:15:5: note: Loop condition is true.  Entering loop body
   15 |     while (player->base.health > 0 && monster->base.health > 0) {
      |     ^
../src/combat_mode.c:16:9: note: Control jumps to 'case MENU_ITEM:'  at line 27
   16 |         switch (current_state) {
      |         ^
../src/combat_mode.c:28:21: note: Calling 'item_menu'
   28 |                 if (item_menu(player, monster)) {// Only attack if item was used
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:164:5: note: 'selected_index' initialized to 0
  164 |     int selected_index = 0;
      |     ^~~~~~~~~~~~~~~~~~
../src/combat_mode.c:170:21: note: Assuming 'i' is >= field 'item_count'
  170 |     for (int i = 0; i < player->item_count; i++) {
      |                     ^~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:170:5: note: Loop condition is false. Execution continues on line 176
  170 |     for (int i = 0; i < player->item_count; i++) {
      |     ^
../src/combat_mode.c:176:5: note: Loop condition is true.  Entering loop body
  176 |     while (true) {
      |     ^
../src/combat_mode.c:183:9: note: Loop condition is false. Execution continues on line 191
  183 |         for (int i = 0; i < usable_item_count; i++) {
      |         ^
../src/combat_mode.c:200:13: note: Assuming field 'type' is equal to TB_EVENT_KEY
  200 |         if (event.type == TB_EVENT_KEY) {
      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:200:9: note: Taking true branch
  200 |         if (event.type == TB_EVENT_KEY) {
      |         ^
../src/combat_mode.c:201:17: note: Assuming the condition is false
  201 |             if (event.key == TB_KEY_ARROW_UP) {
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:201:13: note: Taking false branch
  201 |             if (event.key == TB_KEY_ARROW_UP) {
      |             ^
../src/combat_mode.c:204:24: note: Assuming the condition is false
  204 |             } else if (event.key == TB_KEY_ARROW_DOWN) {
      |                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:204:20: note: Taking false branch
  204 |             } else if (event.key == TB_KEY_ARROW_DOWN) {
      |                    ^
../src/combat_mode.c:207:24: note: Assuming field 'key' is equal to TB_KEY_ENTER
  207 |             } else if (event.key == TB_KEY_ENTER) {
      |                        ^~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:207:20: note: Taking true branch
  207 |             } else if (event.key == TB_KEY_ENTER) {
      |                    ^
../src/combat_mode.c:209:17: note: 3rd function call argument is an uninitialized value
  209 |                 use_item(player, monster, usable_items[selected_index]);
      |                 ^                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/combat_mode.c:221:30: warning: unused parameter 'attacker' [clang-diagnostic-unused-parameter]
  221 | int use_ability(character_t* attacker, character_t* defender, ability_t* ability) {
      |                              ^
../src/combat_mode.c:298:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  298 |     snprintf(player_info, sizeof(player_info), "Player: %s | Health %d", player->name, player->health);
      |     ^~~~~~~~
../src/combat_mode.c:298:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  298 |     snprintf(player_info, sizeof(player_info), "Player: %s | Health %d", player->name, player->health);
      |     ^~~~~~~~
../src/combat_mode.c:303:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  303 |     snprintf(monster_info, sizeof(monster_info), "Monster: %s | Health %d", monster->name, monster->health);
      |     ^~~~~~~~
../src/combat_mode.c:303:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  303 |     snprintf(monster_info, sizeof(monster_info), "Monster: %s | Health %d", monster->name, monster->health);
      |     ^~~~~~~~
../src/combat_mode.c:313:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  313 |     snprintf(monster_sprite, sizeof(monster_sprite), "  (\\_/)\n  (o.o) \n  <( )>  \n");
      |     ^~~~~~~~
../src/combat_mode.c:313:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  313 |     snprintf(monster_sprite, sizeof(monster_sprite), "  (\\_/)\n  (o.o) \n  <( )>  \n");
      |     ^~~~~~~~
../src/combat_mode.c:343:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  343 |     snprintf(message, sizeof(message), "Enemy %s attacked! Dealt %d damage. Press any key to continue...", monster->base.name, damage_dealt);
      |     ^~~~~~~~
../src/combat_mode.c:343:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  343 |     snprintf(message, sizeof(message), "Enemy %s attacked! Dealt %d damage. Press any key to continue...", monster->base.name, damage_dealt);
      |     ^~~~~~~~
../src/combat_mode.c:352:13: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  352 |             snprintf(message, sizeof(message), "Used %s! Healed %d. Press any key to continue...", item->base.name, item->value);
      |             ^~~~~~~~
../src/combat_mode.c:352:13: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  352 |             snprintf(message, sizeof(message), "Used %s! Healed %d. Press any key to continue...", item->base.name, item->value);
      |             ^~~~~~~~
../src/combat_mode.c:356:13: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  356 |             snprintf(message, sizeof(message), "Used %s! Increased armor by %d. Press any key to continue...", item->base.name, item->value);
      |             ^~~~~~~~
../src/combat_mode.c:356:13: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  356 |             snprintf(message, sizeof(message), "Used %s! Increased armor by %d. Press any key to continue...", item->base.name, item->value);
      |             ^~~~~~~~
../src/database/database.c:8:9: warning: Call to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    8 |         fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db_connection->db));
      |         ^~~~~~~
../src/database/database.c:8:9: note: Call to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11
    8 |         fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db_connection->db));
      |         ^~~~~~~
../src/database/database.c:26:2: warning: no newline at end of file [clang-diagnostic-newline-eof]
   26 | }
      |  ^
../src/database/local/local_database.c:68:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   68 |     snprintf(local_string_stmt, buffer_size, "SELECT %s%s", language->column_name, LOCAL_STRING_STATEMENT);
      |     ^~~~~~~~
../src/database/local/local_database.c:68:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
   68 |     snprintf(local_string_stmt, buffer_size, "SELECT %s%s", language->column_name, LOCAL_STRING_STATEMENT);
      |     ^~~~~~~~
../src/database/local/local_database.c:89:12: warning: returning 'const char *' from a function with result type 'char *' discards qualifiers [clang-diagnostic-incompatible-pointer-types-discards-qualifiers]
   89 |     return localization_string;
      |            ^~~~~~~~~~~~~~~~~~~
../src/items.c:4:5: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    4 |     strncpy(item->base.name, name, sizeof(item->base.name) - 1);
      |     ^~~~~~~
../src/items.c:4:5: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
    4 |     strncpy(item->base.name, name, sizeof(item->base.name) - 1);
      |     ^~~~~~~
../src/items.c:12:5: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   12 |     strncpy(item->base.name, name, sizeof(item->base.name) - 1);
      |     ^~~~~~~
../src/items.c:12:5: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
   12 |     strncpy(item->base.name, name, sizeof(item->base.name) - 1);
      |     ^~~~~~~
../src/logging/logger.c:72:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   72 |     snprintf(name, 16, LOG_FILE_FORMAT, file_id);
      |     ^~~~~~~~
../src/logging/logger.c:72:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
   72 |     snprintf(name, 16, LOG_FILE_FORMAT, file_id);
      |     ^~~~~~~~
../src/logging/logger.c:75:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   75 |     snprintf(filename, 256, "%s/%s", LOG_DIRECTORY, name);
      |     ^~~~~~~~
../src/logging/logger.c:75:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
   75 |     snprintf(filename, 256, "%s/%s", LOG_DIRECTORY, name);
      |     ^~~~~~~~
../src/logging/logger.c:135:13: warning: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  135 |         if (sscanf(entry->d_name, LOG_FILE_FORMAT, &id) == 1 && id >= 0 && id < MAX_N_FILES) {
      |             ^~~~~~
../src/logging/logger.c:135:13: note: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11
  135 |         if (sscanf(entry->d_name, LOG_FILE_FORMAT, &id) == 1 && id >= 0 && id < MAX_N_FILES) {
      |             ^~~~~~
../src/logging/logger.c:137:13: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  137 |             snprintf(filepath, sizeof(filepath), "%s/%s", LOG_DIRECTORY, entry->d_name);
      |             ^~~~~~~~
../src/logging/logger.c:137:13: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  137 |             snprintf(filepath, sizeof(filepath), "%s/%s", LOG_DIRECTORY, entry->d_name);
      |             ^~~~~~~~
../src/logging/logger.c:212:5: warning: Call to function 'vsnprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'vsnprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  212 |     vsnprintf(msg, sizeof(msg), format, args);
      |     ^~~~~~~~~
../src/logging/logger.c:212:5: note: Call to function 'vsnprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'vsnprintf_s' in case of C11
  212 |     vsnprintf(msg, sizeof(msg), format, args);
      |     ^~~~~~~~~
../src/logging/logger.c:212:5: warning: Function 'vsnprintf' is called with an uninitialized va_list argument [clang-analyzer-valist.Uninitialized]
  212 |     vsnprintf(msg, sizeof(msg), format, args);
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/logging/logger.c:202:9: note: Assuming 'level' is >= MAX_LOG_LEVEL
  202 |     if (level >= MAX_LOG_LEVEL) {
      |         ^~~~~~~~~~~~~~~~~~~~~~
../src/logging/logger.c:202:5: note: Taking true branch
  202 |     if (level >= MAX_LOG_LEVEL) {
      |     ^
../src/logging/logger.c:212:5: note: Function 'vsnprintf' is called with an uninitialized va_list argument
  212 |     vsnprintf(msg, sizeof(msg), format, args);
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../src/logging/logger.c:215:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  215 |     snprintf(log_msg, MAX_MSG_LENGTH, MSG_FORMAT, timestamp, log_level, module, msg);
      |     ^~~~~~~~
../src/logging/logger.c:215:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  215 |     snprintf(log_msg, MAX_MSG_LENGTH, MSG_FORMAT, timestamp, log_level, module, msg);
      |     ^~~~~~~~
../src/logging/logger.c:266:31: warning: unused parameter 'arg' [clang-diagnostic-unused-parameter]
  266 | void* log_writer_thread(void* arg) {
      |                               ^
../src/logging/logger.c:276:17: warning: Call to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  276 |                 fprintf(log_file, "%s", log_msg);
      |                 ^~~~~~~
../src/logging/logger.c:276:17: note: Call to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11
  276 |                 fprintf(log_file, "%s", log_msg);
      |                 ^~~~~~~
../src/logging/ringbuffer.c:85:9: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   85 |         snprintf(buffer->messages[buffer->tail], MAX_MSG_LENGTH, "%s", message);
      |         ^~~~~~~~
../src/logging/ringbuffer.c:85:9: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
   85 |         snprintf(buffer->messages[buffer->tail], MAX_MSG_LENGTH, "%s", message);
      |         ^~~~~~~~
../src/logging/ringbuffer.c:105:5: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  105 |     snprintf(message, MAX_MSG_LENGTH, "%s", buffer->messages[buffer->head]);
      |     ^~~~~~~~
../src/logging/ringbuffer.c:105:5: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  105 |     snprintf(message, MAX_MSG_LENGTH, "%s", buffer->messages[buffer->head]);
      |     ^~~~~~~~
../src/map/map_mode.c:117:32: warning: incompatible pointer types passing 'struct tb_event *' to parameter of type 'const struct tb_event *' [clang-diagnostic-incompatible-pointer-types]
  117 |     db_printEventStruct(3, 20, &ev);
      |                                ^~~
../src/map/../../debug/debug.h:4:63: note: passing argument to parameter 'event' here
    4 | void db_printEventStruct(int x, int y, const struct tb_event *event);
      |                                                               ^
Suppressed 1 warnings (1 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
